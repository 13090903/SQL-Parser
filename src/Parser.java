/* Generated By:JavaCC: Do not edit this line. Parser.java */
public class Parser implements ParserConstants {
    public static String parse(String args) throws Exception
    {
        Parser parse = new Parser(new java.io.StringReader(args));
        return Query();
    }

    static public String Query() throws ParseException {
        String rst;
        rst = SFWStatement();
        jj_consume_token(0);
        {if (true) return rst;}
        throw new Error("Missing return statement in function");
    }
    static public String SFWStatement() throws ParseException {
        String select = "";
        String from = "";
        String where = "";
        select = SelectClause();
        from = FromClause();
        where = WhereClause();
        {if (true) return select + from + where;}
        throw new Error("Missing return statement in function");
    }

    static public String SelectClause() throws ParseException {
        String select;
        jj_consume_token(SELECT);
        select = Attribute();
        {if (true) return "├ SELECT\n" + select;}
        throw new Error("Missing return statement in function");
    }
    static public String Attribute() throws ParseException {
        Token relation;
        Token attribute;
        String subAttribute = "";
        relation = jj_consume_token(NAME);
        jj_consume_token(DOT);
        attribute = jj_consume_token(NAME);
        label_1:
        while (true) {
            if (((jj_ntk == -1) ? jj_ntk() : jj_ntk) == COMMA) {

            } else {
                jj_la1[0] = jj_gen;
                break;
            }
            jj_consume_token(COMMA);
            subAttribute = Attribute();
        }
        {if (true) return "├— Attribute\n" + "│  ├ Table " + relation.image + "\n" + "│  └ AttributeName " + attribute.image + "\n" + subAttribute;}
        throw new Error("Missing return statement in function");
    }

    static public String FromClause() throws ParseException {
        String from;
        jj_consume_token(FROM);
        from = RelVal();
        {if (true) return "├— FROM\n" + from;}
        throw new Error("Missing return statement in function");
    }

    static public String RelVal() throws ParseException {
        Token realName;
        Token aliasName;
        String subVal = "";
        realName = jj_consume_token(NAME);
        aliasName = jj_consume_token(NAME);
        label_2:
        while (true) {
            if (((jj_ntk == -1) ? jj_ntk() : jj_ntk) == COMMA) {
            } else {
                jj_la1[1] = jj_gen;
                break label_2;
            }
            jj_consume_token(COMMA);
            subVal = RelVal();
        }
        {if (true) return "│  └ Table\n" + "│    ├ TableName " + realName.image + "\n" + "│    └ TableAliasName " + aliasName.image + "\n" + subVal;}
        throw new Error("Missing return statement in function");
    }

    static public String WhereClause() throws ParseException {
        String where = "";
        jj_consume_token(WHERE);
        where = Expression(false);
        {if (true) return "├— WHERE\n" + where;}
        throw new Error("Missing return statement in function");
    }

    static public String Expression(boolean hasFather) throws ParseException {
        String exp1 = "";
        String exp2 = "";
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case OPEN_PAR -> {
                jj_consume_token(OPEN_PAR);
                exp1 = Expression(true);
                jj_consume_token(CLOSE_PAR);
                label_3:
                while (true) {
                    if (((jj_ntk == -1) ? jj_ntk() : jj_ntk) == AND) {
                    } else {
                        jj_la1[2] = jj_gen;
                        break label_3;
                    }
                    jj_consume_token(AND);
                    exp2 = Expression(true);
                }
                if (hasFather && exp2.equals("")) {
                    return exp1;
                }
                return "│  └Expression\n" + exp1 + exp2;
            }
            case QUO, DIGITS, NAME -> {
                exp1 = Factor();
                label_4:
                while (true) {
                    if (((jj_ntk == -1) ? jj_ntk() : jj_ntk) == AND) {
                    } else {
                        jj_la1[3] = jj_gen;
                        break label_4;
                    }
                    jj_consume_token(AND);
                    exp2 = Expression(true);
                }
                if (hasFather && exp2.equals("")) {
                    return exp1;
                } else {
                    {
                        if (true) return "│  └ Expression\n" + exp1 + exp2;
                    }
                }
            }
            default -> {
                jj_la1[4] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        throw new Error("Missing return statement in function");
    }

    /*
    1. it is a table.Attributeibute. such as "Emp.Name = Dep.MName"
    2. it is a string literal. such as "Emp.Name = "james""
    3. it is a integer literal. such as "Emp.Salary = 7000"
    */
    static public String Factor() throws ParseException {
        String left = "";
        String right = "";
        String operator;
        left = BooleanAttribute();
        operator = Operator();
        right = BooleanAttribute();
        {if (true) return "│    └ ExpressionPart\n" + left + operator + right;}
        throw new Error("Missing return statement in function");
    }

    /*
    1. name.name such as "Emp.Name"
    2. String Literal such as "James"
    3. Integer Literal such as 7000
    */
    static public String BooleanAttribute() throws ParseException {
        Token rel;
        Token attribute;
        String attributeName = "";
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case DIGITS -> {
                rel = jj_consume_token(DIGITS);
                {
                    if (true)
                        return "│      └ CONST\n│        └ " + rel.image + "\n";
                }
            }
            case NAME -> {
                rel = jj_consume_token(NAME);
                jj_consume_token(DOT);
                attribute = jj_consume_token(NAME);
                {
                    if (true)
                        return "│      └ Attribute\n" + "│      │ ├ TableAliasName " + rel.image + "\n" + "│      │ └ AttributeName " + attribute.image + "\n";
                }
            }
            case QUO -> {
                jj_consume_token(QUO);
                rel = jj_consume_token(NAME);
                jj_consume_token(QUO);
                {
                    if (true)
                        return "│      └ CONST\n│        └ " + rel.image + "\n";
                }
            }
            default -> {
                jj_la1[5] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
        }
        throw new Error("Missing return statement in function");
    }

    /*this method will check the operator and return it as it is. */
    static final public String Operator() throws ParseException {
        Token operator;
        operator = jj_consume_token(OPERATOR);
        {if (true) return "│      └ OPERATOR\n│      │ └ " + operator.image + "\n";}
        throw new Error("Missing return statement in function");
    }

    static private boolean jj_initialized_once = false;
    static public ParserTokenManager token_source;
    static SimpleCharStream jj_input_stream;
    static public Token token;
    static public Token jj_nt;
    static private int jj_ntk;
    static private int jj_gen;
    static final private int[] jj_la1 = new int[6];
    static private int[] jj_la1_0;
    static {
        jj_la1_init_0();
    }
    private static void jj_la1_init_0() {
        jj_la1_0 = new int[] {0x1000,0x1000,0x100,0x100,0x1a200,0x1a000,};
    }

    public Parser(java.io.InputStream stream) {
        this(stream, null);
    }
    public Parser(java.io.InputStream stream, String encoding) {
        if (jj_initialized_once) {
            System.out.println("ERROR: Second call to constructor of static parser.  ");
            System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
            System.out.println("       during parser generation.");
            throw new Error();
        }
        jj_initialized_once = true;
        try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
        token_source = new ParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 6; i++) jj_la1[i] = -1;
    }

    /** Reinitialise. */
    static public void ReInit(java.io.InputStream stream) {
        ReInit(stream, null);
    }
    /** Reinitialise. */
    static public void ReInit(java.io.InputStream stream, String encoding) {
        try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
        ParserTokenManager.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 6; i++) jj_la1[i] = -1;
    }

    /** Constructor. */
    public Parser(java.io.Reader stream) {
        if (jj_initialized_once) {
            System.out.println("ERROR: Second call to constructor of static parser. ");
            System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
            System.out.println("       during parser generation.");
            throw new Error();
        }
        jj_initialized_once = true;
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new ParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 6; i++) jj_la1[i] = -1;
    }
    static private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null) token = token.next;
        else token = token.next = ParserTokenManager.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }


    static private int jj_ntk() {
        if ((jj_nt=token.next) == null)
            return (jj_ntk = (token.next= ParserTokenManager.getNextToken()).kind);
        else
            return (jj_ntk = jj_nt.kind);
    }

    static private final java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
    static private int jj_kind = -1;

    static public ParseException generateParseException() {
        jj_expentries.clear();
        boolean[] la1tokens = new boolean[17];
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 6; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1<<j)) != 0) {
                        la1tokens[j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 17; i++) {
            if (la1tokens[i]) {
                int[] jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.add(jj_expentry);
            }
        }
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = jj_expentries.get(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

}
